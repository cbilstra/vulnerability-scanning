import datetime
import glob
import json
import time

import sys

import os
import numpy as np
import re


def transform_datetime(input_datetime):
    return datetime.datetime.utcfromtimestamp(input_datetime / 1000).strftime('%Y-%m-%d %H:%M:%S')


def process_data(filepath: str, ssh=False, mysql=False, smtp=False, snmp=False, pop3=False):
    start_time = time.monotonic()

    if os.name == 'nt':
        filename_search = re.compile(r'\\(?P<filename>[\w]+)\.json')
    else:
        filename_search = re.compile(r'/(?P<filename>[\w]+)\.json')

    print(f"Extracting {filepath}")
    with open(filepath, mode='r') as file:
        column_types = [
            # ('hash', 'U32'),
            ('ip', 'U15'), ('banner', 'object'),
            # ('country', object), ('city', object),
            # ('region', object), ('latitude', object), ('longitude', object),
            ('datetime', 'U20')
        ]
        entries = []
        counter = 0
        try:
            while line := next(file):
                entry = json.loads(line)

                # Skip if this is not telnet over TCP
                if ssh:
                    if entry['name'] != 'ssh' or entry['proto'] != 'tcp':
                        continue
                if mysql:
                    if entry['name'] != 'mysql' or entry['proto'] != 'tcp':
                        continue
                if smtp:
                    if entry['name'] != 'smtp' or entry['proto'] != 'tcp':
                        continue
                if snmp:
                    if entry['name'] != 'snmp' or entry['proto'] != 'udp':
                        continue
                if pop3:
                    if entry['name'] != 'pop3' or entry['proto'] != 'tcp':
                        continue

                # Leave out geo information if it is not present and continue
                # if entry['geo'] is None:
                #     entries.append((entry['_id']['h'],                          # hash
                #                     entry['ip'],                                # ip
                #                     entry['banner'],                            # banner
                #                     None,                                       # country
                #                     None,                                       # city
                #                     None,                                       # region
                #                     None,                                       # latitude
                #                     None,                                       # longitude
                #                     transform_datetime(entry['t']['$date'])     # datetime
                #                     ))
                #     continue

                # Extract latitude and longitude if available
                # latitude, longitude = None, None
                # if 'loc' in entry['geo']:
                #     latitude, longitude = entry['geo']['loc']

                # Append this entry
                entries.append((
                    # entry['_id']['h'],                          # hash
                    entry['ip'],                                # ip
                    entry['banner'],                            # banner
                    # entry['geo'].get('c'),                      # country
                    # entry['geo'].get('city'),                   # city
                    # entry['geo'].get('reg'),                    # region
                    # latitude,                                   # latitude
                    # longitude,                                  # longitude
                    transform_datetime(entry['t']['$date'])     # datetime
                ))
                if len(entries) > 10000000:
                    matches = filename_search.search(filepath)
                    filename = matches.group('filename')

                    print(f"Saving 10000000 entries to processed_data/{filename}_{counter}.npz")
                    entries = np.array(entries, dtype=column_types)
                    np.savez_compressed(f'processed_data/{filename}_{counter}.npz', entries)

                    counter += 1
                    entries = []

        except StopIteration:
            pass

    print(f'filepath: {filepath}')
    matches = filename_search.search(filepath)
    print(f'matches: {matches}')

    filename = matches.group('filename')

    print(f"Saving the entries to processed_data/{filename}_{counter}.npz")
    entries = np.array(entries, dtype=column_types)
    np.savez_compressed(f'processed_data/{filename}_{counter}.npz', entries)

    print(f"Took {time.monotonic() - start_time}s in total")


files = list(glob.iglob('raw_data/*.json'))
files.sort()


def process_mysql():
    for filepath in files:
        if "_3306" not in filepath:
            continue
        process_data(filepath, mysql=True)


def process_ssh():
    for filepath in files:
        if "_22" not in filepath:
            continue
        process_data(filepath, ssh=True)


def process_smtp():
    for filepath in files:
        if "_25" not in filepath:
            continue
        process_data(filepath, smtp=True)


def process_snmp():
    # Cisco IOS
    for filepath in files:
        if "_161" not in filepath:
            continue
        process_data(filepath, snmp=True)


def process_pop3():
    for filepath in files:
        if "_110" not in filepath:
            continue
        process_data(filepath, pop3=True)


# map the inputs to the function blocks
param_functions = {'mysql': process_mysql,
                   'ssh': process_ssh,
                   'smtp': process_smtp,
                   'snmp': process_snmp,
                   'pop3': process_pop3
                   }


if __name__ == '__main__':

    if len(sys.argv) < 2:
        print('No parameters provided please provide one of the following:')
        for param in param_functions.keys():
            print(param)
    else:
        parameter = sys.argv[1]
        if parameter not in param_functions.keys():
            print('Wrong parameter provided please provide one of the following:')
            for param in param_functions.keys():
                print(param)
        else:
            # Execute parameter
            param_functions[parameter]()

    print("Processing finished")
