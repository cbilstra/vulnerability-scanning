import numpy as np
import datetime
import glob
from typing import Callable
import math
import statistics

countries_usa = ["USA"]
countries_eu = ["AUT", "BEL", "BGR", "CYP", "CZE", "DNK", "EST", "FIN", "FRA", "DEU", "GRC", "HUN",
                "ITA", "LVA", "LTU", "LUX", "MLT", "NLD", "POL", "PRT", "IRL", "ROU", "SVK", "SVN",
                "ESP", "SWE", "GBR"]  # List of country states at 31 december 2012 (all except Croatia and incl. the UK)


def calculate(patch_date: datetime.datetime, get_version_number: Callable, is_vulnerable: Callable,
              search_banner, countries=None, ssh=False, mysql=False):
    print("Start calculating MDP")

    vulnerable_ips = {}
    ips_running_software = set()

    total_patch_times = []

    files = list(glob.iglob('processed_data/*.npz'))
    files.sort()

    for filepath in files:
        if not ssh:
            if "_22" in filepath:
                continue
        if not mysql:
            if "_3306" in filepath:
                continue
        print(f"Processing {filepath}")
        entries = np.load(filepath, allow_pickle=True)['arr_0']

        # Extract services and version
        scans = []
        for banner in entries['banner']:
            if search_banner in banner:
                version = get_version_number(banner)

                if version is not None:
                    scans.append((version, is_vulnerable(version)))
                else:
                    # print(f"Could not parse banner {banner}")
                    scans.append(None)
            else:
                scans.append(None)

        software_name = "MySQL" if search_banner == "" else search_banner

        print(f"Loaded {len(entries)} scan results of which "
              f"{len([s for s in scans if s is not None])} were {software_name} services.")

        for entry, scan_result in zip(entries, scans):
            if scan_result is None:
                continue

            if countries is not None and entry['country'] not in countries:
                continue

            ip = entry['ip']
            ips_running_software.add(ip)
            _, vulnerable = scan_result

            if not vulnerable and ip in vulnerable_ips:
                new_date = entry['datetime']

                patch_time = datetime.datetime.strptime(new_date, '%Y-%m-%d %H:%M:%S') - patch_date
                patch_time_in_seconds = patch_time.total_seconds()

                # In case a company patched before the CVE was published, the patch time may be negative
                if patch_time_in_seconds > 0:
                    total_patch_times.append(patch_time_in_seconds)

                del vulnerable_ips[ip]

            elif vulnerable:
                if ip not in vulnerable_ips:
                    vulnerable_ips[ip] = entry['datetime']

        del entries

    total_patch_times.sort()
    print(total_patch_times[:20])
    median = statistics.median(total_patch_times)
    mean = statistics.mean(total_patch_times)

    print(f"{len(ips_running_software)} unique IPs were found")
    print(f"Average patch time (in seconds): {round(mean, 2)}, "
          f"(in days): {round(mean/60./60./24., 2)}, Median patch time (in days): {round(median/60./60./24., 2)}, "
          f"tracked ips: {len(total_patch_times)}, {len(vulnerable_ips)} still vulnerable")
