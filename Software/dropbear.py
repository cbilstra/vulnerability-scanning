# import geopandas
from matplotlib import pyplot as plt
import numpy as np
from shapely.geometry import Point
import datetime
from DMDP import calculate

banner = 'SSH-2.0-dropbear'
patch_date = datetime.datetime.strptime("2012-06-05", '%Y-%m-%d') # Patched on 2012-02-22, CVE published on 2012-06-05


def mdp():
    calculate(patch_date, get_version_number, is_vulnerable, banner, ssh=True)


def get_version_number(input_banner: str):
    dropbear_tag = input_banner[input_banner.find(banner):]
    try:
        return dropbear_tag.split("\r")[0].split("_")[1]
    except IndexError as e:
        print(input_banner)
        return None


def is_vulnerable(input_version) -> bool:
    ver = int(input_version.split(".")[1][:2])
    if 52 <= ver <= 54:
        return True

    return False


def plot():

    arrays = np.load('processed_data/critical_201209_22.npz', allow_pickle=True)
    entries = arrays['arr_0']

    # Extract dropbear services and version
    dropbear_scans = []
    for b in entries['banner']:
        if banner in b:
            dropbear_scans.append((version := get_version_number(banner), is_vulnerable(version)))
        else:
            dropbear_scans.append(None)

    print(f"Loaded {len(entries)} scan results of which "
          f"{len([s for s in dropbear_scans if s is not None])} were Dropbear services.")

    # Extract plot data: only the services that run dropbear and have coordinates
    vulnerable_locations = []
    safe_locations = []
    vulnerable_in = {}
    safe_in = {}
    for entry, dropbear_scan in zip(entries, dropbear_scans):
        if dropbear_scan is None or entry['latitude'] is None:
            continue

        _, vulnerable = dropbear_scan
        point = Point(entry['longitude'], entry['latitude'])

        if vulnerable:
            vulnerable_locations.append(point)
        else:
            safe_locations.append(point)

        # For the 'patch level': Percentage of patched servers per region (state in the US)
        if entry['country'] != 'USA' or entry['region'] is None:
            continue

        if entry['region'] not in vulnerable_in:
            # If this region is new we initialize it to 0 in the dictionaries
            vulnerable_in[entry['region']] = 0
            safe_in[entry['region']] = 0

        if vulnerable:
            vulnerable_in[entry['region']] += 1
        else:
            safe_in[entry['region']] += 1

    vulnerable_data = geopandas.GeoDataFrame({'geometry': vulnerable_locations}, crs='EPSG:4326')
    safe_data = geopandas.GeoDataFrame({'geometry': safe_locations}, crs='EPSG:4326')

    # Plot the map with points (green = safe, red = vulnerable)
    world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
    world = world[(world.pop_est > 0) & (world.name != "Antarctica")]

    base = world.plot(color='lightgray', edgecolor='black', figsize=(16, 7))

    safe_data = safe_data.to_crs(world.crs)
    vulnerable_data = vulnerable_data.to_crs(world.crs)

    safe_data.plot(ax=base, color='green', markersize=0.2, alpha=0.2, label='Not vulnerable')
    vulnerable_data.plot(ax=base, color='red', markersize=0.2, alpha=0.2, label='Vulnerable')

    plt.title("SSH servers running Dropbear in September 2012")
    legend = plt.legend()
    for handle in legend.legendHandles:
        # Dirty hack to make the markers in the legend more visible, trademark: Jelle Vos
        handle.set_alpha(1)
        handle.set_sizes([2 if s == 0.2 else s for s in handle.get_sizes()])

    plt.savefig('plots/dropbear_09_2012.png')
    plt.show()

    # Plot the map with the US (download from https://www2.census.gov/geo/tiger/GENZ2018/shp/cb_2018_us_state_20m.zip)
    states = geopandas.read_file('map_data/cb_2018_us_state_20m.shp')
    # Exclude Hawaii, Alaska, Puerto Rico, Rhode Island, District of Columbia, Delaware
    states = states.drop(states.index[states.NAME == "Hawaii"])
    states = states.drop(states.index[states.NAME == "Alaska"])
    states = states.drop(states.index[states.NAME == "Puerto Rico"])
    states = states.drop(states.index[states.NAME == "Rhode Island"])
    states = states.drop(states.index[states.NAME == "District of Columbia"])
    states = states.drop(states.index[states.NAME == "Delaware"])

    # Extract patch level and total number of IPs per state
    patch_level = []
    total_ips = []
    for abbreviation in states['STUSPS']:
        if abbreviation not in vulnerable_in:
            patch_level.append(None)
            continue

        total = vulnerable_in[abbreviation] + safe_in[abbreviation]

        patch_level.append(safe_in[abbreviation] / total)
        total_ips.append(total)

    states['patch_level'] = patch_level
    states['total_ips'] = total_ips
    states = states.to_crs("EPSG:3395")

    # Plot the actual map
    fig = plt.figure(1, figsize=(35, 22))
    ax = fig.add_subplot()
    states.apply(lambda x: ax.annotate(text=f"{x.NAME}\n{round(x.patch_level * 100)}% of {x.total_ips}", xy=x.geometry.centroid.coords[0], ha='center', fontsize=11), axis=1)
    states.boundary.plot(ax=ax, color='Black', linewidth=.4)
    states.plot(ax=ax, column='patch_level', cmap='RdYlGn', vmin=0, vmax=1)

    plt.axis('off')

    plt.savefig('plots/dropbear_09_2012_patch_level.png')
    plt.show()


if __name__ == '__main__':
    mdp()
